// ============================================================================
// i2c_master.v — Bit-level I2C master (open-drain), 1B write + N-byte read
// - SYS_CLK_FREQ : system clock (Hz)
// - I2C_CLK_FREQ : I2C bus clock (Hz) — 100k/400k önerilir
// Arayüz:
//   start_i   : 1 clk pulse → işlemi başlatır
//   rw_i      : 0=write(1 byte), 1=read(N bytes)
//   addr_i    : 7-bit slave address (TMP117 için 7'h48)
//   wr_data_i : write modunda gönderilecek tek byte
//   rd_len_i  : read modunda okunacak byte sayısı (1..255)
//   busy_o    : işlem boyunca 1
//   done_o    : işlem bitiminde 1 clk pulse
//   ack_err_o : herhangi bir ACK beklemesinde NACK görülürse 1
//   rd_data_o : read sırasında alınan byte
//   rd_valid_o: rd_data_o geçerli olduğunda 1 clk pulse
// I/O:
//   sda_io, scl_io : open-drain (harici pull-up gerekli)
// ============================================================================
module i2c_master
#(
    parameter integer SYS_CLK_FREQ = 100_000_000,
    parameter integer I2C_CLK_FREQ =     100_000
)
(
    input  clk_i,
    input  rst_al_i,

    input  start_i,
    input  rw_i,
    input  [6:0] addr_i,
    input  [7:0] wr_data_i,
    input  [7:0] rd_len_i,

    output busy_o,
    output done_o,
    output ack_err_o,
    output [7:0] rd_data_o,
    output rd_valid_o,

    inout  sda_io,
    inout  scl_io
);

    // ---------------- Clock phase (4 faz/scl): 0..3 ----------------
    localparam integer PH_TICKS = SYS_CLK_FREQ / (I2C_CLK_FREQ * 4);
    reg [$clog2(PH_TICKS)-1:0] ph_cnt_r;
    reg [1:0]                  ph_r;
    wire                       ph_tick_w = (ph_cnt_r == PH_TICKS-1);

    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) begin
            ph_cnt_r <= {($clog2(PH_TICKS)){1'b0}};
            ph_r     <= 2'd0;
        end else begin
            if (ph_tick_w) begin
                ph_cnt_r <= {($clog2(PH_TICKS)){1'b0}};
                ph_r     <= ph_r + 2'd1;
            end else begin
                ph_cnt_r <= ph_cnt_r + {{($clog2(PH_TICKS)-1){1'b0}},1'b1};
            end
        end
    end

    // ---------------- Open-drain sürüş (SCL/SDA) -------------------
    // SCL: low fazlarda 0 sür, high fazlarda Z bırak → harici pull-up ile HIGH
    reg scl_oe_r;   // 1 => LOW sür, 0 => Z
    reg sda_oe_r;   // 1 => LOW sür, 0 => Z

    assign scl_io = (scl_oe_r == 1'b1) ? 1'b0 : 1'bz;
    assign sda_io = (sda_oe_r == 1'b1) ? 1'b0 : 1'bz;

    always @(*) begin
        scl_oe_r = (ph_r[1] == 1'b0);  // ph=0/1 low; ph=2/3 high
    end

    // ---------------- FSM & veri yolları ---------------------------
    localparam [3:0]
        S_IDLE  = 4'd0,
        S_START = 4'd1,
        S_ADDR  = 4'd2,
        S_ACK1  = 4'd3,
        S_WBYTE = 4'd4,
        S_WACK  = 4'd5,
        S_RBYTE = 4'd6,
        S_RACK  = 4'd7,
        S_STOP  = 4'd8,
        S_DONE  = 4'd9;

    reg  [3:0] state_r;
    reg  [2:0] bitcnt_r;            // 7..0
    reg  [7:0] shifter_r;
    reg  [7:0] rd_data_r;
    reg  [7:0] rd_left_r;
    reg        busy_r, done_r, ack_err_r, rd_valid_r;
    reg        start_ff_r;

    assign busy_o     = busy_r;
    assign done_o     = done_r;
    assign ack_err_o  = ack_err_r;
    assign rd_data_o  = rd_data_r;
    assign rd_valid_o = rd_valid_r;

    wire start_pulse_w = start_i & ~start_ff_r;
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) start_ff_r <= 1'b0;
        else           start_ff_r <= start_i;
    end

    // SDA sürüş kararı (komb): “0” göndermek/ACK basmak gerektiğinde LOW sür
    reg sda_drive_low_c;

    always @(*) begin
        sda_oe_r = ( (ph_r[1] == 1'b0) && (sda_drive_low_c == 1'b1) ) ? 1'b1 : 1'b0;
    end

    // ---------------- Ana FSM (sadece ph_tick’te ilerler) ----------
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) begin
            state_r        <= S_IDLE;
            bitcnt_r       <= 3'd0;
            shifter_r      <= 8'h00;
            rd_data_r      <= 8'h00;
            rd_left_r      <= 8'd0;
            busy_r         <= 1'b0;
            done_r         <= 1'b0;
            ack_err_r      <= 1'b0;
            rd_valid_r     <= 1'b0;
            sda_drive_low_c<= 1'b0;
        end else begin
            // defaultlar (clk başına)
            done_r     <= 1'b0;
            rd_valid_r <= 1'b0;
            sda_drive_low_c <= 1'b0;

            if (ph_tick_w) begin
                case (state_r)
                    // ------------------------------------------------
                    S_IDLE: begin
                        if (start_pulse_w && !busy_r) begin
                            busy_r    <= 1'b1;
                            ack_err_r <= 1'b0;
                            shifter_r <= {addr_i, rw_i}; // 7b addr + R/W
                            bitcnt_r  <= 3'd7;
                            // START: SCL high (ph=2/3) iken SDA’yı LOW yapmak için
                            // bir periyot boyunca LOW sürmeye hazırlan.
                            sda_drive_low_c <= 1'b1;
                            state_r   <= S_START;
                        end
                    end
                    // ------------------------------------------------
                    S_START: begin
                        // START sonrası ADDRESS bitlerini gönder
                        // bit=0 → LOW sür; bit=1 → Z (pull-up’la HIGH)
                        sda_drive_low_c <= (shifter_r[7] == 1'b0);
                        if (ph_r == 2'd1) begin
                            // low faz biterken bir sonraki bite hazırlık
                            if (bitcnt_r == 3'd0) begin
                                state_r <= S_ACK1; // ACK bekleme
                            end else begin
                                shifter_r <= {shifter_r[6:0],1'b0};
                                bitcnt_r  <= bitcnt_r - 3'd1;
                            end
                        end
                    end
                    // ------------------------------------------------
                    S_ACK1: begin
                        // ACK aşaması: SDA release (Z), SCL high iken oku
                        // comb’da sda_drive_low_c=0 (release)
                        if (ph_r == 2'd3) begin
                            ack_err_r <= sda_io; // 0=ACK, 1=NACK
                            if (rw_i == 1'b0) begin
                                // WRITE: tek byte yolla
                                shifter_r <= wr_data_i;
                                bitcnt_r  <= 3'd7;
                                state_r   <= S_WBYTE;
                            end else begin
                                // READ: çok byte
                                bitcnt_r  <= 3'd7;
                                rd_left_r <= (rd_len_i == 8'd0) ? 8'd1 : rd_len_i;
                                state_r   <= S_RBYTE;
                            end
                        end
                    end
                    // ------------------------------------------------
                    S_WBYTE: begin
                        sda_drive_low_c <= (shifter_r[7] == 1'b0);
                        if (ph_r == 2'd1) begin
                            if (bitcnt_r == 3'd0) begin
                                state_r <= S_WACK; // ACK bekle
                            end else begin
                                shifter_r <= {shifter_r[6:0],1'b0};
                                bitcnt_r  <= bitcnt_r - 3'd1;
                            end
                        end
                    end
                    S_WACK: begin
                        // release; high fazda oku
                        if (ph_r == 2'd3) begin
                            ack_err_r <= ack_err_r | sda_io;
                            state_r   <= S_STOP;
                        end
                    end
                    // ------------------------------------------------
                    S_RBYTE: begin
                        // Okuma: SDA release; SCL high fazında bit örnekle
                        if (ph_r == 2'd3) begin
                            shifter_r[bitcnt_r] <= sda_io;
                            if (bitcnt_r == 3'd0) begin
                                rd_data_r  <= shifter_r;
                                rd_valid_r <= 1'b1;
                                state_r    <= S_RACK;
                            end
                        end else if (ph_r == 2'd1) begin
                            if (bitcnt_r != 3'd0) bitcnt_r <= bitcnt_r - 3'd1;
                        end
                    end
                    S_RACK: begin
                        // Devam varsa ACK(LOW), son ise NACK(release)
                        if (rd_left_r > 8'd1) begin
                            sda_drive_low_c <= 1'b1; // ACK bitini LOW sür
                        end else begin
                            sda_drive_low_c <= 1'b0; // NACK: release
                        end
                        if (ph_r == 2'd3) begin
                            if (rd_left_r > 8'd1) begin
                                rd_left_r <= rd_left_r - 8'd1;
                                bitcnt_r  <= 3'd7;
                                state_r   <= S_RBYTE;
                            end else begin
                                state_r   <= S_STOP;
                            end
                        end
                    end
                    // ------------------------------------------------
                    S_STOP: begin
                        // STOP: SCL high iken SDA 0→1
                        // low fazda SDA=0 tut, high fazda release
                        if (ph_r[1] == 1'b0) sda_drive_low_c <= 1'b1; else sda_drive_low_c <= 1'b0;
                        if (ph_r == 2'd3) begin
                            state_r <= S_DONE;
                        end
                    end

                    S_DONE: begin
                        busy_r <= 1'b0;
                        done_r <= 1'b1;
                        state_r<= S_IDLE;
                    end

                    default: state_r <= S_IDLE;
                endcase
            end
        end
    end

endmodule

~
// ============================================================================
// tmp117_controller.v — TMP117 (7.6 Register Map) sıcaklık okuma denetleyici
// Akış:
//  1) START + (addr|W) + 0x00(pointer=Temp) + STOP
//  2) START + (addr|R) ile 2 byte oku: MSB(ACK), LSB(NACK) + STOP
// Çıkışlar:
//   temp_raw_o   : {MSB,LSB}  — iki’sinin tümleyen işaretli 16-bit
//   data_valid_o : 1 clk pulse (temp_raw_o güncellendiğinde)
//   ack_error_o  : herhangi bir aşamada NACK görülürse 1
// ============================================================================
module tmp117_controller
#(
    parameter integer CLK_FREQ_HZ  = 100_000_000,
    parameter integer I2C_FREQ_HZ  =     100_000,
    parameter [6:0]  DEV_ADDR_7BIT = 7'h48
)
(
    input  clk_i,
    input  rst_al_i,

    input  start_i,           // 1 clk pulse → bir ölçüm oku

    inout  sda_io,
    inout  scl_io,

    output data_valid_o,
    output [15:0] temp_raw_o,
    output ack_error_o
);

    // -------- I2C master instance --------
    wire        m_busy_w, m_done_w, m_ack_w, m_rv_w;
    wire [7:0]  m_rd_w;
    reg         m_start_r, m_rw_r;
    reg  [6:0]  m_addr_r;
    reg  [7:0]  m_wdata_r, m_rdlen_r;

    i2c_master #(
        .SYS_CLK_FREQ (CLK_FREQ_HZ),
        .I2C_CLK_FREQ (I2C_FREQ_HZ)
    ) u_i2c (
        .clk_i      (clk_i),
        .rst_al_i   (rst_al_i),
        .start_i    (m_start_r),
        .rw_i       (m_rw_r),
        .addr_i     (m_addr_r),
        .wr_data_i  (m_wdata_r),
        .rd_len_i   (m_rdlen_r),
        .busy_o     (m_busy_w),
        .done_o     (m_done_w),
        .ack_err_o  (m_ack_w),
        .rd_data_o  (m_rd_w),
        .rd_valid_o (m_rv_w),
        .sda_io     (sda_io),
        .scl_io     (scl_io)
    );

    // -------- Controller FSM --------
    localparam [2:0]
        C_IDLE  = 3'd0,
        C_WPTR  = 3'd1,
        C_WWAIT = 3'd2,
        C_RREQ  = 3'd3,
        C_RWAIT = 3'd4,
        C_DONE  = 3'd5;

    reg [2:0]  cs_r;
    reg [15:0] temp_r;
    reg        dv_r;
    reg        ack_or_r;
    reg        have_msb_r;

    reg        start_ff_r;
    wire       start_pulse_w = start_i & ~start_ff_r;
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) start_ff_r <= 1'b0;
        else           start_ff_r <= start_i;
    end

    assign temp_raw_o   = temp_r;
    assign data_valid_o = dv_r;
    assign ack_error_o  = ack_or_r;

    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) begin
            cs_r       <= C_IDLE;
            m_start_r  <= 1'b0;
            m_rw_r     <= 1'b0;
            m_addr_r   <= DEV_ADDR_7BIT;
            m_wdata_r  <= 8'h00;
            m_rdlen_r  <= 8'd0;
            temp_r     <= 16'h0000;
            dv_r       <= 1'b0;
            ack_or_r   <= 1'b0;
            have_msb_r <= 1'b0;
        end else begin
            // defaultlar
            m_start_r <= 1'b0;
            dv_r      <= 1'b0;

            case (cs_r)
                C_IDLE: begin
                    if (start_pulse_w) begin
                        // 1) pointer = 0x00
                        m_addr_r  <= DEV_ADDR_7BIT;
                        m_rw_r    <= 1'b0;        // write
                        m_wdata_r <= 8'h00;       // pointer=Temperature
                        m_start_r <= 1'b1;
                        cs_r      <= C_WWAIT;
                    end
                end

                C_WWAIT: begin
                    if (m_done_w) begin
                        ack_or_r <= m_ack_w;
                        // 2) 2 byte read
                        m_rw_r    <= 1'b1;
                        m_rdlen_r <= 8'd2;
                        m_start_r <= 1'b1;
                        have_msb_r<= 1'b0;
                        cs_r      <= C_RREQ;
                    end
                end

                C_RREQ: begin
                    // master başlamış olacak; veriler geldikçe topla
                    cs_r <= C_RWAIT;
                end

                C_RWAIT: begin
                    if (m_rv_w) begin
                        if (!have_msb_r) begin
                            temp_r[15:8] <= m_rd_w;
                            have_msb_r   <= 1'b1;
                        end else begin
                            temp_r[7:0]  <= m_rd_w;
                        end
                    end
                    if (m_done_w) begin
                        ack_or_r <= ack_or_r | m_ack_w;
                        cs_r     <= C_DONE;
                    end
                end

                C_DONE: begin
                    dv_r  <= 1'b1;        // 1 clk pulse
                    cs_r  <= C_IDLE;
                end

                default: cs_r <= C_IDLE;
            endcase
        end
    end

endmodule

~

// ============================================================================
// uart_tx.v — Basit 8N1 verici
// ============================================================================
module uart_tx
#(
    parameter integer CLK_FREQ_HZ = 100_000_000,
    parameter integer BAUD        =     115_200
)
(
    input  clk_i,
    input  rst_al_i,

    input  tx_start_i,         // 1 clk pulse
    input  [7:0] tx_data_i,
    output tx_busy_o,
    output tx_o
);
    localparam integer DIV = CLK_FREQ_HZ / BAUD;

    reg        busy_r;
    reg [3:0]  bitpos_r;       // 0..9 (start + 8 data + stop)
    reg [7:0]  data_r;
    reg [15:0] cnt_r;
    reg        tx_r;

    assign tx_busy_o = busy_r;
    assign tx_o      = tx_r;

    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) begin
            busy_r  <= 1'b0;
            bitpos_r<= 4'd0;
            data_r  <= 8'h00;
            cnt_r   <= 16'd0;
            tx_r    <= 1'b1; // idle=1
        end else begin
            if (!busy_r) begin
                if (tx_start_i) begin
                    busy_r   <= 1'b1;
                    bitpos_r <= 4'd0;
                    data_r   <= tx_data_i;
                    cnt_r    <= 16'd0;
                    tx_r     <= 1'b0; // start bit
                end
            end else begin
                if (cnt_r == DIV-1) begin
                    cnt_r <= 16'd0;
                    bitpos_r <= bitpos_r + 4'd1;
                    case (bitpos_r)
                        4'd0:   tx_r <= data_r[0];
                        4'd1:   tx_r <= data_r[1];
                        4'd2:   tx_r <= data_r[2];
                        4'd3:   tx_r <= data_r[3];
                        4'd4:   tx_r <= data_r[4];
                        4'd5:   tx_r <= data_r[5];
                        4'd6:   tx_r <= data_r[6];
                        4'd7:   tx_r <= data_r[7];
                        4'd8:   tx_r <= 1'b1;     // stop
                        4'd9: begin
                            tx_r   <= 1'b1;       // idle
                            busy_r <= 1'b0;
                        end
                        default: ;
                    endcase
                end else begin
                    cnt_r <= cnt_r + 16'd1;
                end
            end
        end
    end
endmodule

~

// ============================================================================
// tmp117_uart_top.v — TMP117 okur, "±DD.DDD°C\r\n" olarak UART'a basar
// ============================================================================
module tmp117_uart_top
#(
    parameter integer CLK_FREQ_HZ  = 100_000_000,
    parameter integer I2C_FREQ_HZ  =     100_000,
    parameter integer BAUD         =     115_200
)
(
    input  clk_i,
    input  rst_al_i,

    inout  sda_io,
    inout  scl_io,

    output uart_tx_o
);
    // ---- TMP117 controller ----
    wire        dv_w;
    wire [15:0] raw_w;
    wire        ackerr_w;

    // 1 Hz tetik (her saniye bir ölçüm iste)
    reg [31:0] sec_cnt_r;
    wire       kick_w = (sec_cnt_r == CLK_FREQ_HZ-1);
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i)       sec_cnt_r <= 32'd0;
        else if (kick_w)     sec_cnt_r <= 32'd0;
        else                 sec_cnt_r <= sec_cnt_r + 32'd1;
    end

    reg start_req_r;
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) start_req_r <= 1'b0;
        else            start_req_r <= kick_w;  // 1 clk pulse
    end

    tmp117_controller #(
        .CLK_FREQ_HZ (CLK_FREQ_HZ),
        .I2C_FREQ_HZ (I2C_FREQ_HZ),
        .DEV_ADDR_7BIT(7'h48)
    ) u_tmp117 (
        .clk_i        (clk_i),
        .rst_al_i     (rst_al_i),
        .start_i      (start_req_r),
        .sda_io       (sda_io),
        .scl_io       (scl_io),
        .data_valid_o (dv_w),
        .temp_raw_o   (raw_w),
        .ack_error_o  (ackerr_w)
    );

    // ---- raw → milli-°C (signed) ----
    // TMP117 LSB = 0.0078125 °C = 1/128 °C
    // mC = raw * 1000 / 128
    reg signed [31:0] mC_r;
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) mC_r <= 32'sd0;
        else if (dv_w) mC_r <= ( $signed({{16{raw_w[15]}},raw_w}) * 32'sd1000 ) >>> 7;
    end

    // ---- UART TX ----
    wire       tx_busy_w;
    reg        tx_go_r;
    reg [7:0]  tx_data_r;

    uart_tx #(
        .CLK_FREQ_HZ (CLK_FREQ_HZ),
        .BAUD        (BAUD)
    ) u_tx (
        .clk_i       (clk_i),
        .rst_al_i    (rst_al_i),
        .tx_start_i  (tx_go_r),
        .tx_data_i   (tx_data_r),
        .tx_busy_o   (tx_busy_w),
        .tx_o        (uart_tx_o)
    );

    // ---- Basit formatter: "TMP117: ±DD.DDD°C\r\n" ----
    // mC → sign + int + frac3
    reg        fmt_run_r;
    reg [3:0]  step_r;
    reg        sign_neg_r;
    reg [31:0] abs_mC_r;
    reg [15:0] deg_r;    // integer °C
    reg [9:0]  frac_r;   // 0..999

    function [7:0] ascii; input [3:0] d; begin ascii = 8'd48 + d[3:0]; end endfunction

    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) begin
            fmt_run_r  <= 1'b0;
            step_r     <= 4'd0;
            tx_go_r    <= 1'b0;
            tx_data_r  <= 8'h00;
            sign_neg_r <= 1'b0;
            abs_mC_r   <= 32'd0;
            deg_r      <= 16'd0;
            frac_r     <= 10'd0;
        end else begin
            tx_go_r <= 1'b0;

            // Yeni veri gelince dönüştürmeyi başlat
            if (dv_w && !fmt_run_r) begin
                fmt_run_r  <= 1'b1;
                step_r     <= 4'd0;
                sign_neg_r <= (mC_r < 0);
                abs_mC_r   <= (mC_r < 0) ? -mC_r : mC_r;
                deg_r      <= ((mC_r < 0) ? -mC_r : mC_r) / 32'd1000;
                frac_r     <= ((mC_r < 0) ? -mC_r : mC_r) % 32'd1000;
            end

            if (fmt_run_r && !tx_busy_w) begin
                case (step_r)
                    // "T","M","P","1","1","7",":"," "
                    4'd0:  begin tx_data_r<=8'h54; tx_go_r<=1'b1; step_r<=4'd1; end
                    4'd1:  begin tx_data_r<=8'h4D; tx_go_r<=1'b1; step_r<=4'd2; end
                    4'd2:  begin tx_data_r<=8'h50; tx_go_r<=1'b1; step_r<=4'd3; end
                    4'd3:  begin tx_data_r<=8'h31; tx_go_r<=1'b1; step_r<=4'd4; end
                    4'd4:  begin tx_data_r<=8'h31; tx_go_r<=1'b1; step_r<=4'd5; end
                    4'd5:  begin tx_data_r<=8'h37; tx_go_r<=1'b1; step_r<=4'd6; end
                    4'd6:  begin tx_data_r<=8'h3A; tx_go_r<=1'b1; step_r<=4'd7; end
                    4'd7:  begin tx_data_r<=8'h20; tx_go_r<=1'b1; step_r<=4'd8; end
                    // sign
                    4'd8:  begin tx_data_r<= sign_neg_r ? 8'h2D : 8'h2B; tx_go_r<=1'b1; step_r<=4'd9; end
                    // DD (yüzler+onlar+birler — leading zero’ları da yazar)
                    4'd9:  begin tx_data_r<= ascii( (deg_r/100)%10 ); tx_go_r<=1'b1; step_r<=4'd10; end
                    4'd10: begin tx_data_r<= ascii( (deg_r/10)%10  ); tx_go_r<=1'b1; step_r<=4'd11; end
                    4'd11: begin tx_data_r<= ascii( deg_r%10 );       tx_go_r<=1'b1; step_r<=4'd12; end
                    // "."
                    4'd12: begin tx_data_r<=8'h2E; tx_go_r<=1'b1; step_r<=4'd13; end
                    // DDD (millicelsius)
                    4'd13: begin tx_data_r<= ascii( (frac_r/100)%10 ); tx_go_r<=1'b1; step_r<=4'd14; end
                    4'd14: begin tx_data_r<= ascii( (frac_r/10)%10  ); tx_go_r<=1'b1; step_r<=4'd15; end
                    4'd15: begin tx_data_r<= ascii( frac_r%10 );       tx_go_r<=1'b1; step_r<=4'd16; end
                    // "°","C","\r","\n"
                    4'd16: begin tx_data_r<=8'hC2; tx_go_r<=1'b1; step_r<=4'd17; end // UTF-8 '°' = C2 B0 (isteğe bağlı)
                    4'd17: begin tx_data_r<=8'hB0; tx_go_r<=1'b1; step_r<=4'd18; end
                    4'd18: begin tx_data_r<=8'h43; tx_go_r<=1'b1; step_r<=4'd19; end // 'C'
                    4'd19: begin tx_data_r<=8'h0D; tx_go_r<=1'b1; step_r<=4'd20; end
                    4'd20: begin tx_data_r<=8'h0A; tx_go_r<=1'b1; step_r<=4'd21; end
                    default: begin fmt_run_r<=1'b0; end
                endcase
            end
        end
    end

endmodule

*smoke
module i2c_smoke
#(
    parameter SYS_CLK = 100_000_000,
    parameter I2C_CLK =     100_000
)
(
    input  clk_i,
    input  rst_al_i,
    inout  sda_io,
    inout  scl_io,
    output led_busy_o,
    output led_done_o
);
    // 10 ms'de bir start pulse
    reg [20:0] cnt_r;
    wire tick_w = (cnt_r == (SYS_CLK/100)-1); // 10 ms
    always @(posedge clk_i or negedge rst_al_i)
        if(!rst_al_i) cnt_r <= 21'd0;
        else if (tick_w) cnt_r <= 21'd0;
        else cnt_r <= cnt_r + 21'd1;

    reg start_r;
    always @(posedge clk_i or negedge rst_al_i)
        if(!rst_al_i) start_r <= 1'b0;
        else          start_r <= tick_w; // 1-clk pulse

    wire busy_w, done_w, ackerr_w, rd_valid_w;
    wire [7:0] rd_data_w;

    i2c_master #(
        .SYS_CLK_FREQ(SYS_CLK),
        .I2C_CLK_FREQ(I2C_CLK)
    ) u_i2c (
        .clk_i     (clk_i),
        .rst_al_i  (rst_al_i),
        .start_i   (start_r),
        .rw_i      (1'b0),          // write
        .addr_i    (7'h48),         // TMP117 addr
        .wr_data_i (8'h00),         // pointer
        .rd_len_i  (8'd0),          // yazmada kullanılmaz
        .busy_o    (busy_w),
        .done_o    (done_w),
        .ack_err_o (ackerr_w),
        .rd_data_o (rd_data_w),
        .rd_valid_o(rd_valid_w),
        .sda_io    (sda_io),
        .scl_io    (scl_io)
    );

    assign led_busy_o = busy_w;
    assign led_done_o = done_w;
endmodule 

#

// i2c_master.v — Verilog-2001, open-drain I2C master (1B write + NB read)
// START/STOP SCL=HIGH iken SDA değişimine izin verir (kritik düzeltme)
module i2c_master
#(
    parameter SYS_CLK_FREQ = 100_000_000,
    parameter I2C_CLK_FREQ =     100_000
)
(
    input  clk_i,
    input  rst_al_i,

    input  start_i,            // 1-clk pulse
    input  rw_i,               // 0=write(1B), 1=read(NB)
    input  [6:0] addr_i,
    input  [7:0] wr_data_i,
    input  [7:0] rd_len_i,     // 1..255

    output busy_o,
    output done_o,
    output ack_err_o,
    output [7:0] rd_data_o,
    output rd_valid_o,

    inout  sda_io,
    inout  scl_io
);

    // -------- 4-faz clock: ph=0/1: SCL LOW, ph=2/3: SCL HIGH --------
    localparam PH_TICKS = SYS_CLK_FREQ / (I2C_CLK_FREQ * 4);
    reg [15:0] ph_cnt_r;
    reg [1:0]  ph_r;
    wire       ph_tick_w = (ph_cnt_r == PH_TICKS-1);

    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) begin
            ph_cnt_r <= 16'd0;
            ph_r     <= 2'd0;
        end else begin
            if (ph_tick_w) begin
                ph_cnt_r <= 16'd0;
                ph_r     <= ph_r + 2'd1;
            end else begin
                ph_cnt_r <= ph_cnt_r + 16'd1;
            end
        end
    end

    // -------- Open-drain hat sürüşü --------
    reg scl_oe_r;      // 1→LOW sür, 0→Z (pull-up ile HIGH)
    reg sda_oe_r;      // 1→LOW sür, 0→Z

    assign scl_io = (scl_oe_r == 1'b1) ? 1'b0 : 1'bz;
    assign sda_io = (sda_oe_r == 1'b1) ? 1'b0 : 1'bz;

    // SCL: low fazlarda LOW sür, high fazlarda release
    always @(*) begin
        scl_oe_r = (ph_r[1] == 1'b0);
    end

    // -------- Durumlar --------
    localparam S_IDLE   = 4'd0,
               S_STRT_W = 4'd1,   // START oluştur (SCL HIGH iken SDA LOW)
               S_ADDR   = 4'd2,   // 7b addr + R/W
               S_ACK1   = 4'd3,   // addr ACK
               S_WBYTE  = 4'd4,   // write data
               S_WACK   = 4'd5,   // write ACK
               S_RBYTE  = 4'd6,   // read data
               S_RACK   = 4'd7,   // master ACK/NACK
               S_STOP   = 4'd8,   // STOP (SCL HIGH iken SDA LOW->HIGH)
               S_DONE   = 4'd9;

    reg [3:0] state_r;
    reg [2:0] bitcnt_r;
    reg [7:0] shifter_r;
    reg [7:0] rd_data_r;
    reg [7:0] rd_left_r;
    reg       busy_r, done_r, ack_err_r, rd_valid_r;
    reg       start_ff_r;

    assign busy_o     = busy_r;
    assign done_o     = done_r;
    assign ack_err_o  = ack_err_r;
    assign rd_data_o  = rd_data_r;
    assign rd_valid_o = rd_valid_r;

    wire start_pulse_w = start_i & ~start_ff_r;
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) start_ff_r <= 1'b0;
        else           start_ff_r <= start_i;
    end

    // -------- Ana FSM --------
    always @(posedge clk_i or negedge rst_al_i) begin
        if (!rst_al_i) begin
            state_r   <= S_IDLE;
            bitcnt_r  <= 3'd0;
            shifter_r <= 8'h00;
            rd_data_r <= 8'h00;
            rd_left_r <= 8'd0;
            busy_r    <= 1'b0;
            done_r    <= 1'b0;
            ack_err_r <= 1'b0;
            rd_valid_r<= 1'b0;
            sda_oe_r  <= 1'b0;   // release
        end else begin
            // varsayılanlar
            done_r     <= 1'b0;
            rd_valid_r <= 1'b0;

            if (ph_tick_w) begin
                case (state_r)
                    // ------------------------------------------------
                    S_IDLE: begin
                        sda_oe_r <= 1'b0; // release
                        if (start_pulse_w && !busy_r) begin
                            busy_r    <= 1'b1;
                            ack_err_r <= 1'b0;
                            shifter_r <= {addr_i, rw_i};
                            bitcnt_r  <= 3'd7;
                            state_r   <= S_STRT_W;
                        end
                    end
                    // ------------------------------------------------
                    S_STRT_W: begin
                        // START: SCL HIGH iken SDA LOW yap
                        if (ph_r[1] == 1'b1) sda_oe_r <= 1'b1;  // SDA=LOW
                        // Bir HIGH fazını gördükten sonra adrese geç
                        if (ph_r == 2'd3) state_r <= S_ADDR;
                    end
                    // ------------------------------------------------
                    S_ADDR: begin
                        // Bit değeri SCL LOW fazında hazırlanır
                        if (ph_r == 2'd0) begin
                            // bit=0 ise LOW sür; bit=1 ise release
                            sda_oe_r <= (shifter_r[7] == 1'b0) ? 1'b1 : 1'b0;
                        end
                        // LOW faz sonunda bir sonraki bite ilerle
                        if (ph_r == 2'd1) begin
                            if (bitcnt_r == 3'd0) begin
                                // ACK için SDA release (slave sürer)
                                sda_oe_r <= 1'b0;
                                state_r  <= S_ACK1;
                            end else begin
                                shifter_r <= {shifter_r[6:0],1'b0};
                                bitcnt_r  <= bitcnt_r - 3'd1;
                            end
                        end
                    end
                    // ------------------------------------------------
                    S_ACK1: begin
                        // ACK’i SCL HIGH fazında oku
                        if (ph_r == 2'd3) begin
                            ack_err_r <= sda_io; // 0=ACK, 1=NACK
                            if (rw_i == 1'b0) begin
                                shifter_r <= wr_data_i; bitcnt_r <= 3'd7;
                                state_r   <= S_WBYTE;
                            end else begin
                                bitcnt_r  <= 3'd7;
                                rd_left_r <= (rd_len_i == 8'd0) ? 8'd1 : rd_len_i;
                                state_r   <= S_RBYTE;
                            end
                        end
                    end
                    // ------------------------------------------------
                    S_WBYTE: begin
                        if (ph_r == 2'd0) begin
                            sda_oe_r <= (shifter_r[7] == 1'b0) ? 1'b1 : 1'b0;
                        end
                        if (ph_r == 2'd1) begin
                            if (bitcnt_r == 3'd0) begin
                                sda_oe_r <= 1'b0;  // release → ACK zamanı
                                state_r  <= S_WACK;
                            end else begin
                                shifter_r <= {shifter_r[6:0],1'b0};
                                bitcnt_r  <= bitcnt_r - 3'd1;
                            end
                        end
                    end
                    S_WACK: begin
                        if (ph_r == 2'd3) begin
                            ack_err_r <= ack_err_r | sda_io;
                            state_r   <= S_STOP;
                        end
                    end
                    // ------------------------------------------------
                    S_RBYTE: begin
                        // Okuma: SDA hep release; SCL HIGH’da örnekle
                        sda_oe_r <= 1'b0;
                        if (ph_r == 2'd3) begin
                            rd_data_r[bitcnt_r] <= sda_io;
                            if (bitcnt_r == 3'd0) begin
                                rd_valid_r <= 1'b1;
                                state_r    <= S_RACK;
                            end
                        end else if (ph_r == 2'd1) begin
                            if (bitcnt_r != 3'd0) bitcnt_r <= bitcnt_r - 3'd1;
                        end
                    end
                    S_RACK: begin
                        // Devam edecekse ACK (LOW), son ise NACK (release)
                        if (ph_r == 2'd0) begin
                            if (rd_left_r > 8'd1) sda_oe_r <= 1'b1; else sda_oe_r <= 1'b0;
                        end
                        if (ph_r == 2'd3) begin
                            if (rd_left_r > 8'd1) begin
                                rd_left_r <= rd_left_r - 8'd1;
                                bitcnt_r  <= 3'd7;
                                state_r   <= S_RBYTE;
                            end else begin
                                state_r   <= S_STOP;
                            end
                        end
                    end
                    // ------------------------------------------------
                    S_STOP: begin
                        // STOP: SCL HIGH iken SDA LOW→HIGH
                        // Önce SCL LOW fazında SDA’yı LOW yap, sonra HIGH fazında release
                        if (ph_r[1] == 1'b0) sda_oe_r <= 1'b1; else sda_oe_r <= 1'b0;
                        if (ph_r == 2'd3) state_r <= S_DONE;
                    end

                    S_DONE: begin
                        busy_r <= 1'b0;
                        done_r <= 1'b1;
                        state_r<= S_IDLE;
                    end

                    default: state_r <= S_IDLE;
                endcase
            end
        end
    end
endmodule 
.......
`timescale 1ns/1ps
//==============================================================================
// Testbench : tb_ltc2666_system.v
// Amaç      : LTC2666 controller için kapsamlı, self-checking sim senaryoları
// Araçlar   : Vivado xsim/Questa ile çalışır.
// Notlar    : - Testbench kaynak (driver) sinyalleri *_r sonekli (istenen format).
//             - Dahili hafif spi_master_model, echo bozma/sayma yetenekli.
//==============================================================================

//------------------------- Hafif SPI master modeli ----------------------------
// - SPI zamanlamasını bit seviyesinde taklit etmez; handshake + echo davranışı.
// - INJECT_BAD_AT transfer numarasında 1 kez yanlış echo üretir (test amaçlı).
module spi_master_model #(
    parameter integer WIDTH           = 32,
    parameter integer LATENCY_CYC     = 8,
    parameter integer INJECT_BAD_AT   = 0   // 0 => hiç bozma; N => N'inci DONE'da boz
)(
    input               clk_i,
    input               rst_n_i,
    input               spi_enable_i,
    input  [WIDTH-1:0]  tx_data_i,
    output [WIDTH-1:0]  rx_data_o,
    output              data_valid_o,
    output              busy_o,
    // fiziksel hatlar sadece görünürlük için; gerçek dalga üretilmez
    output              mosi_o,
    input               miso_i,
    output              sclk_o,
    output              cs_o
);
    reg [WIDTH-1:0] r_rx, r_prev, r_tx;
    reg [7:0]       r_cnt;
    reg             r_busy, r_done;
    reg [31:0]      r_done_cnt;
    assign rx_data_o    = r_rx;
    assign data_valid_o = r_done;
    assign busy_o       = r_busy;
    assign mosi_o       = 1'b0;
    assign sclk_o       = 1'b0;
    assign cs_o         = 1'b1;

    always @(posedge clk_i or negedge rst_n_i) begin
        if (!rst_n_i) begin
            r_rx<=0; r_prev<=0; r_tx<=0; r_cnt<=0; r_busy<=0; r_done<=0; r_done_cnt<=0;
        end else begin
            r_done<=0;
            if (spi_enable_i && !r_busy) begin
                r_busy   <= 1'b1;
                r_cnt    <= LATENCY_CYC[7:0];
                r_tx     <= tx_data_i;
            end else if (r_busy) begin
                if (r_cnt==0) begin
                    r_busy   <= 1'b0;
                    r_done   <= 1'b1;
                    r_done_cnt <= r_done_cnt + 1;
                    // echo: normalde prev döner, belirli bir done sayısında boz
                    if (INJECT_BAD_AT!=0 && r_done_cnt+1==INJECT_BAD_AT)
                        r_rx <= r_prev ^ {WIDTH{1'b1}};
                    else
                        r_rx <= r_prev;
                    r_prev <= r_tx;
                end else begin
                    r_cnt <= r_cnt - 1'b1;
                end
            end
        end
    end
endmodule

//------------------------------ Testbench -------------------------------------
module tb_ltc2666_system;
    // -------- Parametreler --------
    localparam integer CLK_HZ     = 100_000_000;
    localparam real    CLK_PERIOD = 1e9/CLK_HZ; // ns
    localparam integer FRAME_BITS = 32;         // 32-bit: echo aktif
    localparam integer CLR_CYCLES = 4;

    // -------- Saat / Reset --------
    reg  clk_r;
    reg  rst_n_r;
    initial begin clk_r = 1'b0; forever #(CLK_PERIOD/2.0) clk_r = ~clk_r; end
    initial begin
        rst_n_r = 1'b0;
        #(10*CLK_PERIOD);
        rst_n_r = 1'b1;
    end

    // -------- Mesaj arayüzü (driver, *_r) --------
    reg         msg_valid_r;
    wire        msg_ready_w;
    reg  [3:0]  msg_cmd_r;
    reg  [7:0]  msg_mask_r;
    reg  [15:0] msg_data_r;
    reg         clear_errors_r;

    // -------- CLR / OVRTMP (driver, *_r) --------
    reg         clr_pulse_r;
    wire        clr_n_w;
    reg         ovrtmp_in_r;        // DUT girişine giden TB sürücü
    wire        ovrtmp_irq_w;
    wire        ovrtmp_sticky_w;

    // -------- SPI handshake wires --------
    wire              spi_sclk_w, spi_mosi_w, spi_cs_w;
    wire              spi_miso_w;
    wire              busy_w, done_w, err_illegal_w, err_echo_w;

    // -------- Controller ↔ SPI model bağlantıları --------
    wire                 w_spi_start;
    wire [31:0]          w_spi_tx;
    wire [31:0]          w_spi_rx;
    wire                 w_spi_busy;
    wire                 w_spi_done;

    // -------- DUT: ltc2666_controller (top kullanmadan direkt bağladık) ------
    ltc2666_controller #(
        .FRAME_BITS           (FRAME_BITS),
        .APPEND_NOOP_FOR_ECHO (1),
        .CLR_PULSE_CC         (CLR_CYCLES)
    ) u_ctrl (
        .clk_i          (clk_r),
        .rst_n_i        (rst_n_r),

        .msg_valid_i    (msg_valid_r),
        .msg_ready_o    (msg_ready_w),
        .msg_cmd_i      (msg_cmd_r),
        .msg_chan_mask_i(msg_mask_r),
        .msg_data_i     (msg_data_r),
        .clear_errors_i (clear_errors_r),

        .spi_start_o    (w_spi_start),
        .spi_tx_o       (w_spi_tx),
        .spi_rx_i       (w_spi_rx),
        .spi_busy_i     (w_spi_busy),
        .spi_done_i     (w_spi_done),

        .clr_pulse_i    (clr_pulse_r),
        .clr_n_o        (clr_n_w),
        .ovrtmp_i       (ovrtmp_in_r),
        .ovrtmp_irq_o   (ovrtmp_irq_w),
        .ovrtmp_sticky_o(ovrtmp_sticky_w),

        .busy_o         (busy_w),
        .done_o         (done_w),
        .err_illegal_o  (err_illegal_w),
        .err_echo_o     (err_echo_w),
        .last_echo_exp_o(),
        .last_echo_rx_o ()
    );

    // -------- SPI master model --------
    // INJECT_BAD_AT: 5 → 5. transferin echo'su bozulur (echo hatası testi)
    spi_master_model #(
        .WIDTH(FRAME_BITS),
        .LATENCY_CYC(6),
        .INJECT_BAD_AT(5)
    ) u_spi_m (
        .clk_i        (clk_r),
        .rst_n_i      (rst_n_r),
        .spi_enable_i (w_spi_start),
        .tx_data_i    (w_spi_tx[FRAME_BITS-1:0]),
        .rx_data_o    (w_spi_rx[FRAME_BITS-1:0]),
        .data_valid_o (w_spi_done),
        .busy_o       (w_spi_busy),
        .mosi_o       (spi_mosi_w),
        .miso_i       (spi_miso_w),
        .sclk_o       (spi_sclk_w),
        .cs_o         (spi_cs_w)
    );

    // MISO TB'de kullanılmıyor; model içten bağlar. Burada 0'a sabitleyelim.
    assign spi_miso_w = 1'b0;

    // -------- Komut sabitleri (controller ile aynı nibble'lar) ---------------
    localparam [3:0] CMD_WRITE_CODE_N            = 4'b0000;
    localparam [3:0] CMD_UPDATE_N                = 4'b0001;
    localparam [3:0] CMD_WRITE_CODE_N_UPD_ALL    = 4'b0010;
    localparam [3:0] CMD_WRITE_CODE_N_UPD_N      = 4'b0011;
    localparam [3:0] CMD_POWER_DOWN_N            = 4'b0100;
    localparam [3:0] CMD_POWER_DOWN_CHIP         = 4'b0101;
    localparam [3:0] CMD_WRITE_SPAN_N            = 4'b0110;
    localparam [3:0] CMD_CONFIG                  = 4'b0111;
    localparam [3:0] CMD_WRITE_CODE_ALL          = 4'b1000;
    localparam [3:0] CMD_UPDATE_ALL              = 4'b1001;
    localparam [3:0] CMD_WRITE_CODE_ALL_UPD_ALL  = 4'b1010;
    localparam [3:0] CMD_ANALOG_MUX              = 4'b1011;
    localparam [3:0] CMD_TOGGLE_SELECT           = 4'b1100;
    localparam [3:0] CMD_GLOBAL_TOGGLE           = 4'b1101;
    localparam [3:0] CMD_NOOP                    = 4'b1111;

    // -------- Yardımcı görevler ----------------------------------------------
    task automatic wait_ready;
        begin
            @(posedge clk_r);
            while (!msg_ready_w) @(posedge clk_r);
        end
    endtask

    task automatic pulse_clear_errors;
        begin
            clear_errors_r <= 1'b1;
            @(posedge clk_r);
            clear_errors_r <= 1'b0;
        end
    endtask

    task automatic pulse_clr;
        begin
            clr_pulse_r <= 1'b1;
            @(posedge clk_r);
            clr_pulse_r <= 1'b0;
        end
    endtask

    // self-checking send (timeout + done + opsiyonel illegal beklenir)
    task automatic send_msg_expect(
        input [3:0]  cmd, input [7:0] mask, input [15:0] data,
        input        expect_illegal, input integer timeout_clks
    );
        integer to;
        begin
            wait_ready();
            msg_cmd_r   <= cmd;
            msg_mask_r  <= mask;
            msg_data_r  <= data;
            msg_valid_r <= 1'b1;
            @(posedge clk_r);
            msg_valid_r <= 1'b0;

            // illegal ise anında done gelir, spi_start olmayabilir
            to = 0;
            while (!done_w && to < timeout_clks) begin
                @(posedge clk_r);
                to = to + 1;
            end
            if (!done_w) begin
                $fatal("[%0t] TIMEOUT: done gelmedi (cmd=%0h mask=%0h data=%0h)", $time, cmd, mask, data);
            end

            if (expect_illegal && !err_illegal_w)
                $fatal("[%0t] Beklenen illegal hata gelmedi!", $time);
            if (!expect_illegal && err_illegal_w)
                $fatal("[%0t] Beklenmeyen illegal hata!", $time);

            @(posedge clk_r); // done sonrası bir clock
        end
    endtask

    // SPI start sayacı (NOOP eklendi mi diye bakmak için)
    integer spi_start_count;
    always @(posedge clk_r or negedge rst_n_r) begin
        if (!rst_n_r) spi_start_count <= 0;
        else if (w_spi_start) spi_start_count <= spi_start_count + 1;
    end

    // CLR low sayaç (CLR_PULSE_CC doğrulama)
    integer clr_low_count;
    reg     clr_low_phase;
    always @(posedge clk_r or negedge rst_n_r) begin
        if (!rst_n_r) begin
            clr_low_count <= 0;
            clr_low_phase <= 0;
        end else begin
            if (!clr_n_w) begin
                clr_low_phase <= 1;
                clr_low_count <= clr_low_count + 1;
            end else if (clr_low_phase) begin
                // low fazı bitti ⇒ sayıyı kilitleyip raporlayalım (bir kez)
                $display("[%0t] CLR low toplam %0d clock", $time, clr_low_count);
                // Tekrar test edilirse resetleyelim
                clr_low_phase <= 0;
                clr_low_count <= 0;
            end
        end
    end

    // -------- İzleme / log ----------------------------------------------------
    initial begin
        $display("time      st  ready valid busy  start done  spi_busy spi_done   tx(32)        rx(32)       err_illegal err_echo");
        $monitor("[%0t]  %0d    %0b     %0b    %0b     %0b    %0b      %0b       %08h    %08h       %0b          %0b",
                 $time, u_ctrl.st, msg_ready_w, msg_valid_r, busy_w, u_ctrl.r_spi_start, w_spi_done, w_spi_busy,
                 w_spi_tx, w_spi_rx, err_illegal_w, err_echo_w);
    end

    // -------- Başlangıç değerleri --------------------------------------------
    initial begin
        msg_valid_r     = 0;
        msg_cmd_r       = 0;
        msg_mask_r      = 0;
        msg_data_r      = 0;
        clear_errors_r  = 0;
        clr_pulse_r     = 0;
        ovrtmp_in_r     = 1; // OVRTMP normalde HIGH
    end

    // -------- Senaryolar ------------------------------------------------------
    initial begin : SCENARIOS
        @(posedge rst_n_r);
        $display("\n=== SCENARYO 1: CONFIG (int ref ON, TS ON) ===");
        spi_start_count = 0;
        send_msg_expect(CMD_CONFIG, 8'h00, 16'h0000, /*illegal?*/0, /*timeout*/2000);
        // echo aktif ise son frame'in echo'su için NOOP beklenir → en az 1 start
        if (spi_start_count < 1) $fatal("CONFIG sonrası en az 1 SPI start beklenirdi!");
        $display("CONFIG tamam. spi_start_count=%0d", spi_start_count);

        $display("\n=== SCENARYO 2: WRITE_SPAN_N ALL (±2.5V) ===");
        spi_start_count = 0;
        send_msg_expect(CMD_WRITE_SPAN_N, 8'hFF, 16'h0004, 0, 2000);
        if (spi_start_count < 1) $fatal("SPAN sonrası en az 1 SPI start beklenirdi!");
        $display("SPAN(±2.5V) tamam. spi_start_count=%0d", spi_start_count);

        $display("\n=== SCENARYO 3: WRITE_CODE_N_UPD_N (CH0 & CH2 mid-scale) + UPDATE_ALL ===");
        spi_start_count = 0;
        send_msg_expect(CMD_WRITE_CODE_N_UPD_N, 8'b0000_0101, 16'h8000, 0, 2000);
        // per-channel komutta en az iki kanal için 2 frame, echo NOOP ile 3+ olabilir
        if (spi_start_count < 2) $fatal("Per-channel yazımda en az 2 SPI start beklenirdi!");
        $display("WRITE_CODE_N_UPD_N tamam. spi_start_count=%0d", spi_start_count);

        spi_start_count = 0;
        send_msg_expect(CMD_UPDATE_ALL, 8'h00, 16'h0000, 0, 2000);
        if (spi_start_count < 1) $fatal("UPDATE_ALL sonrası en az 1 SPI start beklenirdi!");
        $display("UPDATE_ALL tamam.");

        $display("\n=== SCENARYO 4: ILLEGAL – WRITE_CODE_N_UPD_ALL için mask multi-bit ===");
        spi_start_count = 0;
        send_msg_expect(CMD_WRITE_CODE_N_UPD_ALL, 8'b0000_0011, 16'h8000, /*illegal*/1, 2000);
        // illegal’da controller SPI başlatmayabilir
        if (spi_start_count != 0) $display("Uyarı: illegal durumda SPI start sayısı = %0d (0 beklenebilirdi)", spi_start_count);
        if (!err_illegal_w) $fatal("err_illegal_w bekleniyordu!");
        // sticky olmayan bir flag; DONE sonrası düşer (biz anında kontrol ettik)

        $display("\n=== SCENARYO 5: ECHO hata enjekte (model 5. DONE'da bozuyor) ===");
        // Birkaç kısa komut gönderelim; en az 5 DONE üretelim ki bozma tetiklensin
        spi_start_count = 0;
        send_msg_expect(CMD_NOOP, 8'h00, 16'h0000, 0, 2000);
        send_msg_expect(CMD_NOOP, 8'h00, 16'h0000, 0, 2000);
        send_msg_expect(CMD_NOOP, 8'h00, 16'h0000, 0, 2000);
        send_msg_expect(CMD_NOOP, 8'h00, 16'h0000, 0, 2000);
        send_msg_expect(CMD_NOOP, 8'h00, 16'h0000, 0, 2000); // burada echo bozulmuş olmalı
        if (!err_echo_w) $fatal("err_echo_w set olmalıydı (echo bozma).");
        $display("ECHO hatası görüldü → şimdi temizleniyor...");
        pulse_clear_errors();
        if (err_echo_w) $fatal("clear_errors sonrası err_echo_w temizlenmedi!");
        $display("ECHO hata temizlendi.");

        $display("\n=== SCENARYO 6: CLR darbesi (LOW süresi doğrulama) ===");
        pulse_clr(); // CLR_PULSE_CC = 4 clock
        // clr_low_count raporu üstteki always bloğundan gelecek
        // küçük bekleme
        repeat(10) @(posedge clk_r);

        $display("\n=== SCENARYO 7: OVRTMP düşen kenar (IRQ + sticky) ve temizleme ===");
        ovrtmp_in_r <= 1'b1; @(posedge clk_r);
        ovrtmp_in_r <= 1'b0; @(posedge clk_r); // falling edge
        if (!ovrtmp_irq_w)   $fatal("OVRTMP IRQ pulse bekleniyordu!");
        if (!ovrtmp_sticky_w)$fatal("OVRTMP sticky bekleniyordu!");
        pulse_clear_errors();
        if (ovrtmp_sticky_w) $fatal("OVRTMP sticky temizlenmedi!");
        $display("OVRTMP IRQ & sticky çalıştı, temizlendi.");

        $display("\n=== TÜM SENARYOLAR BAŞARILI ===");
        #(200*CLK_PERIOD);
        $finish;
    end
endmodule


00000000
`timescale 1ns/1ps
module top_ltc2666_test (
    input        clk_i,      // 100 MHz sistem saat
    input        rst_al_i,   // aktif-düşük reset
    // SPI pinleri
    output       spi_sclk_o,
    output       spi_mosi_o,
    input        spi_miso_i,
    output       spi_cs_al_o,
    output       ltc_clr_al_o,
    // Debug LED’ler
    output [3:0] led_o
);

  //----------------------------------------------------------------
  // Sinyaller
  //----------------------------------------------------------------
  reg  [31:0] tick_cnt_r;
  reg         cmd_we_r;
  reg  [2:0]  cmd_chan_r;
  reg  [15:0] cmd_code_r;

  //----------------------------------------------------------------
  // LTC2666 Controller
  //----------------------------------------------------------------
  wire busy_w, inited_w, conf_err_w, init_failed_w;
  wire echo_err_w, in_range_err_w, ovrtmp_sticky_w;

  ltc2666_controller_single #(
    .CLK_HZ(100_000_000),
    .SPI_SCK_HZ(1_000_000),
    .FRAME_BITS(24),        // 24-bit frame
    .INIT_RETRY_MAX(0),     // sınırsız retry
    .CLR_PULSE_CC(8),
    .SOFTSPAN_CODE(16'h0004),
    .SPAN_MV(2500),
    .ALLOWED_MV(1500)
  ) u_ctrl (
    .clk_i(clk_i),
    .rst_al_i(rst_al_i),

    .cmd_we_i(cmd_we_r),
    .cmd_chan_i(cmd_chan_r),
    .cmd_code_i(cmd_code_r),

    .clr_req_i(1'b0),
    .start_init_i(1'b0),
    .clear_errors_i(1'b0),
    .ovrtmp_al_i(1'b1),   // testte alarm yok

    .busy_o(busy_w),
    .inited_o(inited_w),
    .conf_readback_error_o(conf_err_w),
    .init_failed_o(init_failed_w),
    .echo_error_o(echo_err_w),
    .in_range_error_o(in_range_err_w),
    .ovrtmp_sticky_o(ovrtmp_sticky_w),

    .last_tx_o(),
    .last_rx_o(),

    .spi_sclk_o(spi_sclk_o),
    .spi_mosi_o(spi_mosi_o),
    .spi_miso_i(spi_miso_i),
    .spi_cs_al_o(spi_cs_al_o),
    .ltc_clr_al_o(ltc_clr_al_o)
  );

  //----------------------------------------------------------------
  // Basit Test Mekanizması
  // Her ~2ms’de bir CH0’a artan kod gönder
  //----------------------------------------------------------------
  localparam integer PERIOD_CC = 200_000; // 2 ms @100 MHz
  reg [15:0] dac_code_r;

  always @(posedge clk_i or negedge rst_al_i) begin
    if (!rst_al_i) begin
      tick_cnt_r  <= 0;
      dac_code_r  <= 16'h7000;
      cmd_we_r    <= 1'b0;
      cmd_chan_r  <= 3'd0;
      cmd_code_r  <= 16'd0;
    end else begin
      cmd_we_r <= 1'b0; // default

      if (inited_w && !busy_w) begin
        if (tick_cnt_r >= PERIOD_CC) begin
          tick_cnt_r <= 0;

          // Artan kod üret
          dac_code_r <= dac_code_r + 16'd512;

          // Komut gönder
          cmd_chan_r <= 3'd0;
          cmd_code_r <= dac_code_r;
          cmd_we_r   <= 1'b1;
        end else begin
          tick_cnt_r <= tick_cnt_r + 1;
        end
      end
    end
  end

  //----------------------------------------------------------------
  // LED çıkışları
  //----------------------------------------------------------------
  assign led_o[0] = conf_err_w;
  assign led_o[1] = echo_err_w;
  assign led_o[2] = in_range_err_w;
  assign led_o[3] = init_failed_w;

endmodule


Üretici       | Araç                        | Özellikler                                             | Kullanım Alanı / Güçlü Yanları                           | Dil Desteği               | Fiyat                        | Öneri
--------------|-----------------------------|--------------------------------------------------------|----------------------------------------------------------|---------------------------|------------------------------|---------
Siemens EDA   | Questa Lint / AutoCheck     | Kurumsal lint + DO-254 hazır setler, AutoCheck, CI     | Çok güçlü DO-254, güvenlik kritik; FPGA/ASIC için uygun  | Verilog/SystemVerilog/VHDL| Teklif bazlı (yüksek)        | Öne Çıkan
Cadence       | JasperGold Superlint        | Super-lint + auto-formal, FSM/bus/contention, DFT      | DO-254 uyumlu, güçlü formal altyapı                      | Verilog/SystemVerilog/VHDL| Teklif bazlı (yüksek)        | -
Synopsys      | VC SpyGlass Lint            | Klasik lint, STARC/OpenMORE kural setleri              | ASIC/FPGA için yaygın, DO-254 akışlarında kullanılıyor   | Verilog/SystemVerilog/VHDL| Teklif bazlı (yüksek)        | -
Real Intent   | Ascent Lint                 | Hızlı, düşük gürültülü lint, RTL sign-off odaklı       | FPGA/ASIC projeleri, düşük false positive ihtiyacı olan | Verilog/SystemVerilog/VHDL| Teklif bazlı                 | -
Aldec         | ALINT-PRO                   | Kural temelli lint, CDC/RDC, FSM, DO-254 plug-in       | FPGA (Microchip, Xilinx) için yaygın, DO-254 kural seti | Verilog/VHDL/SystemVerilog| Teklif bazlı; EDU fiyat var  | Öne Çıkan
Blue Pearl    | Visual Verification Suite   | Lint + CDC + SDC, DO-254 doğrulama paketi              | FPGA ekiplerinde popüler, DO-254 desteği var             | Verilog/VHDL/SystemVerilog| Teklif bazlı                 | Öne Çıkan
Sigasi        | Visual HDL                  | IDE içinde coding style, lint, auto-fix, refactor      | FPGA (özellikle VHDL ağırlıklı) tasarımcılar için uygun | VHDL/Verilog              | Plan bazlı, fiyat yok        | -
AMIQ EDA      | DVT IDE                     | IDE tabanlı lint + coding-style, UVM desteği           | ASIC/FPGA, gelişmiş IDE kullanıcıları için               | Verilog/SystemVerilog/VHDL| Teklif bazlı                 | -
CHIPS Alliance| Verible                     | SystemVerilog linter, GitHub Actions entegrasyonu      | Ücretsiz, CI/CD entegrasyonu kolay                       | SystemVerilog             | Ücretsiz                     | Öne Çıkan
Top Contributors| svlint                    | Rust tabanlı, IEEE 1800-2017 uyumlu SV linter          | Ücretsiz, küçük/orta projelerde hızlı kontrol            | SystemVerilog             | Ücretsiz                     | -
Paebbels vb.  | hdl-checker                 | Dil sunucusu tabanlı HDL lint                          | Ücretsiz, VS Code içinde lint                            | VHDL/Verilog/SystemVerilog| Ücretsiz                     | -
AMD           | Vivado Lint / methodology   | RTL lint ve metodoloji DRC                             | Xilinx FPGA projeleri için temel lint                    | Verilog/VHDL/SystemVerilog| Vivado ile ücretsiz          | Öne Çıkan
Intel         | Quartus Design Assistant    | Intel FPGA yönergelerine göre DRC                      | Intel FPGA projeleri için temel lint                     | Verilog/VHDL/SystemVerilog| Quartus ile ücretsiz         | Öne Çıkan



Tabloda her aracın özellikleri, güçlü yanları, dil desteği, fiyat bilgisi yer alıyor. Ayrıca senin belirttiğin Verilog + FPGA + Microchip odaklı kullanım için öne çıkanlar özellikle şunlar:

Aldec ALINT-PRO → Microchip FPGA akışlarında yaygın, DO-254 kural seti var.

Siemens Questa Lint → DO-254 ve güvenlik kritik projeler için çok güçlü.

Blue Pearl VVS → FPGA (özellikle DO-254, Microchip/Xilinx) odaklı.

Vivado / Quartus built-in lint → Eğer sadece FPGA tarafında hızlı temel kontrol gerekiyorsa.

Verible (open-source) → CI/CD entegrasyonu için ücretsiz ve SystemVerilog desteği güçlü.


İstersen bu tabloyu sana Excel dosyası (.xlsx) olarak da çıkarabilirim. Çıkarmamı ister misin?

1) Kurumsal (lint / “super-lint” + statik doğrulama)

Siemens EDA — Questa Lint / AutoCheck (Questa Design Solutions)
Geniş kural setleri, CI entegrasyonu ve hazır DO-254 / ISO 26262 / STARC kontrol setleri sunuyor. AutoCheck ve X-Check ile testbench’siz gelişmiş denetimler mümkün. Fiyat kamuya açık değil (teklif bazlı). 

Cadence — JasperGold Superlint
Klasik lint’e ek olarak auto-formal denetimler (FSM erişilebilirlik, deadlock, bus contention vb.) üreterek “super-lint” düzeyi sağlar; DFT kuralları ve etkileşimli debug arayüzü ile düşük gürültülü sonuç hedeflenir. Fiyat teklif bazlı. 

Synopsys — VC SpyGlass Lint
Erken safha RTL analizi; STARC, OpenMORE gibi yeniden-kullanım/standard uyum kontrol setleriyle gelir. Fiyat teklif bazlı. 

Real Intent — Ascent Lint
Hız ve düşük yanlış-pozitif (“low-noise”) odağıyla RTL sign-off’a yönelik lint. Fiyat: satıcı “bize yazın” diyor (açık fiyat yok). 


2) FPGA/IDE odaklı profesyonel çözümler

Aldec — ALINT-PRO
VHDL/Verilog/SV için kural temelli lint; CDC/RDC, DFT, FSM, isimlendirme, simülasyon-sentez uyumu vb. DO-254 rule plug-in mevcut (STARC/RMM desteği de var). Fiyat ticari olarak teklif bazlı; EDU fiyatları yayımlanmış (ör. “ALINT (EDU)” koltuğu listeleniyor). 

Blue Pearl — Visual Verification Suite
Lint + CDC + SDC/clocking analiz; DO-254 doğrulama paketi ve FPGA akışları için kullanım örnekleri mevcut. “Starter” lisans talep sayfası var; ticari fiyat kamuya açık değil. 

Sigasi Visual HDL (VS Code eklentisi)
IDE içinde derin HDL statik denetimler, otomatik düzeltme/yeniden düzenleme; sürümler/katmanlar var (fiyatlar sitede açık değil, teklif/plan bazlı). 

AMIQ EDA — DVT IDE (Eclipse/VS Code)
SystemVerilog/VHDL vs. için kapsamlı IDE; coding-style denetimleri ve UVM/CI entegrasyonu; fiyat teklif bazlı. 


3) Açık-kaynak (ücretsiz) linters

Verible (CHIPS Alliance) — verible-verilog-lint
SystemVerilog için popüler stil/lint aracı; GitHub Actions ile PR’larda otomatik yorumlayıp CI’ya kolayca entegre edilir. 

svlint
Rust tabanlı, IEEE 1800-2017 uyumlu SystemVerilog linter; paket yöneticilerinden kurulabilir. 

hdl-checker
VHDL/Verilog/SV için dil sunucusu; derleyici çıktılarından yararlanarak statik kontroller yapar (VS Code eklentileriyle kullanılıyor). 


4) FPGA araçlarındaki yerleşik lint/dizayn denetimleri (ücretsiz)

AMD Vivado — Run Linter ve report_methodology ile RTL lint-stili ve metodoloji DRC’leri. 

Intel Quartus Prime — Design Assistant ile Intel yönergelerine göre otomatik DRC ve öneriler. Ayrıca Intel’in Questa FPGA Edition entegrasyonu bulunur (lisanslama Quartus’la ilişkilidir). 



---

DO-254 özelinde notlar

Questa Lint doğrudan DO-254 hazır kural setleri içeriyor ve Siemens’in DO-254 çözüm sayfasında HDL coding standards, izlenebilirlik, tool assessment gibi alanları kapsayan uçtan uca akış özetleniyor. 

ALINT-PRO için DO-254 plug-in (güncel kural paketleriyle) resmi dokümanlarda belirtilmiş. 

Blue Pearl VVS için de DO-254 doğrulama paketi vurgulanıyor. 

Cadence JasperGold Superlint klasik lint’in ötesine geçerek auto-formal ile fonksiyonel hataları erkenden yakalamayı hedefliyor; DO-254 projelerinde “erken sign-off” yaklaşımına uygundur. 



---

Fiyat & lisanslama hakkında gerçekçi beklenti

Büyük EDA çözümleri (Questa, JasperGold, VC SpyGlass, Ascent Lint) için kamuya açık liste fiyatı yok; genellikle yıllık abonelik veya kalıcı + bakım modeliyle teklif bazlı. (Satıcı sayfalarında fiyat yerine “request a quote”/iletişim işaretleri var.) 

Aldec: Ticari fiyat teklif bazlı; üniversite (EDU) lisans bedelleri yayımlanmış (ALINT EDU koltuk ücretleri listeleniyor). Bu, ticari fiyatı doğrudan vermez ama Aldec’in daha ulaşılabilir segmentte de paketleri olduğuna işaret eder. 

Blue Pearl: “Starter”/satın alınmış lisanslar için lisans talep sayfası var; kamuya açık rakam yok. 

Intel Questa FPGA Edition: Quartus ile ilişkilendirilmiş sürüm; “Quartus satın alımıyla ücretsiz” ibaresi ve “ayrı satın alma” notu var (fiyat yine yayınlanmıyor). 

Açık-kaynak (Verible, svlint, hdl-checker): Ücretsizdir; kurumsal akışlarda CI’ya kolay entegre olur. 



---

Hızlı seçim rehberi (özet)

DO-254 / güvenlik-kritik ve kurumsal akış: Siemens Questa Lint (+AutoCheck) veya Cadence JasperGold Superlint → hazır DO-254 kural setleri/auto-formal ve izlenebilirlik akışlarıyla güçlü. Alternatif: Aldec ALINT-PRO + DO-254 plug-in ya da Blue Pearl VVS (FPGA ağırlıklı ekiplerde seviliyor). 

Bütçe-duyarlı / hızlı CI kurulumu: Verible linter (GitHub Actions ile), SystemVerilog için svlint; VHDL ağırlıklıysa hdl-checker. Vivado/Quartus’ın yerleşik linter’ları da ilk savunma hattı olarak faydalı. 


İstersen, senin mevcut dil/kod tabanına (VHDL vs. SystemVerilog), DO-254 gereksinimlerine ve bütçene göre 2–3 araçtan oluşan kısa bir shortlist ve örnek CI kurulumu (Verible + Vivado/Quartus linter raporları + waiver akışı) çıkarayım.




